# 其他文件系统

Be 文件系统只是众多文件系统中的一个例子。每种操作系统都有自己原生的文件系统，各自提供了一些有趣的功能组合。本节将介绍若干在历史上具有代表性的文件系统（如 BSD FFS）、传统的现代文件系统（Linux ext2）、Macintosh 的 HFS，以及其他更先进的当前文件系统（Windows NT 的 NTFS 以及 SGI Irix 的 XFS）。

## 3.1 BSD FFS

大多数当前的文件系统至少部分都可以追溯到 FFS，因此在讨论文件系统时，不提及它就不算完整。BSD FFS（或简称 FFS）在性能和可靠性上超越了之前的 Unix 文件系统，并在近十年内成为健壮性和速度的标杆。FFS 的核心包括：一个超级块（superblock）、一个块位图（block bitmap）、一个 inode 位图（inode bitmap）以及一组预分配的 inode。这一设计理念至今仍构成了许多文件系统的基础。

FFS 第一个也是最简单的性能改进技术，是使用更大的文件系统块（block）大小。FFS 采用任意不小于 4096 字节的 2 的幂作为块大小。仅此一项，就使其性能较先前文件系统翻了一番（McKusick，第196页）。其中的道理很简单：连续的磁盘读取带宽远高于为读取文件的不同块而频繁寻道的带宽。无需多言，连续读写磁盘块始终是访问磁盘的最快方式，这种优势在可预见的未来仍难以超越。

当然，块越大也意味着空间浪费更严重：一个仅有 1 字节的文件也会占用整整一个块。McKusick 报道说，在使用 4096 字节块的文件系统上，存储约 775 MB 文件时，有高达 45.6% 的空间开销（即额外浪费了 353 MB）来保存这些文件。FFS 的解决方案是在块内管理碎片（fragment），最小可细分到 512 字节，通常为 1024 字节。FFS 通过块位图记录所有碎片的状态，而不仅仅是整块，从而既能为大文件保留大块以提升性能，又能避免小文件的大量空间浪费。

FFS 进一步通过最小化磁头移动来提升性能。磁盘驱动器的寻道时间非常可观；通过合理组织磁盘上数据布局，文件系统可以减少寻道开销。为此，FFS 引入了“柱面组”（cylinder group）的概念。利用磁盘的几何结构（磁头数、磁道数、柱面数以及每个磁道的扇区数），物理上将同一柱面上的所有磁道组成一个柱面组（见图3-1）。本质上，柱面组相当于磁盘的一个“竖切片”，在同一柱面组内读取连续块仅需切换磁头，这一电气操作速度远快于机械移动磁头。

在利用柱面组的局部性方面，FFS 还将文件系统的各类元数据按柱面组分散存放。例如，不是在磁盘起始位置放置一个大型位图，而是将块位图、inode 位图和预分配的 inode 都分散到各个柱面组中。同时，FFS 尽量将文件数据分配在靠近其 inode 的位置，以减少读取元数据与访问文件内容之间的长距离寻道。为了均匀地将数据分布到磁盘上，FFS 也会将新创建的目录放置在不同的柱面组中。

对于当时的磁盘驱动器而言，将数据组织到柱面组中大有裨益。但现代磁盘已将物理几何细节隐藏在驱动器控制器中，文件系统难以直接利用这些信息。而驱动器控制器本身反而能更有效、更精准地完成 FFS 曾经负责的工作。柱面组的管理职责已经从文件系统转移到磁盘驱动器。

FFS 的另一主要目标是通过精心排序元数据的写入来提高文件系统的可靠性。对元数据更新进行有序写入，使得一致性检查程序（fsck）在崩溃时能够更容易地恢复。如果 fsck 发现不一致的数据，就能根据现有内容推断出崩溃发生时系统的操作意图，进而纠正错误。通常情况下，FFS 的 fsck 能将文件系统恢复到一致状态。该恢复过程需要对文件系统做多达五次的检查与修复，时间开销取决于文件系统的大小和文件数量。

除了写入顺序之外，FFS 还要求所有元数据写入都必须同步完成。例如删除文件时，对目录的更新必须立即写入磁盘，而不能缓存在内存中。同步写元数据可保证：凡是修改元数据的调用一旦返回，就意味着磁盘上的数据确实已被更改。但元数据写入通常是少量的、分散的单块写操作，并几乎不具备连续性，将文件系统可支持的最大 I/O 操作数限制在磁盘多次单块写入速度之下，这是对性能的巨大制约。

总体而言，FFS 在当时为 Unix 文件系统带来了前所未有的性能和可靠性提升。通过利用柱面组的局部性，在上世纪八十年代中期的硬件条件下取得了显著的性能增益；而精心排序、同步写入元数据，则在崩溃恢复方面提供了强有力的保障。尽管现代磁盘和新一代文件系统在性能和可靠性上均已超越 FFS，但它曾一度奠定了 Unix 文件系统设计的标准。

## 3.2 Linux ext2

 Linux ext2 文件系统是对经典 Unix 文件系统的一种惊人快速的实现。ext2 支持的唯一非标准特性是访问控制列表（ACL）。它通过放宽一致性模型，并依赖一个非常复杂的文件系统检查程序来修复崩溃造成的损坏，从而获得卓越的速度。

Linux ext2 与 FFS 在很多方面都非常相似，尽管它并不使用柱面组来划分磁盘分配，而是依赖驱动器自身进行重映射。ext2 仅将磁盘划分为若干固定大小的块组，每个块组都像一个迷你文件系统，拥有完整的超级块、块位图、inode 位图和 inode 表。这样，即便磁盘的大部分区域无法访问，文件系统一致性检查程序仍能在各个块组内恢复文件。

ext2 与 FFS 的主要区别在于，ext2 对文件系统的一致性及文件系统调用完成时操作是否已真正写入磁盘不作任何保证。实际上，ext2 将几乎所有操作都缓存在内存中，只有在需要刷新缓冲区时才写入磁盘。这使其在性能基准测试中（尤其是完全驻留于内存的测试）表现极为出色；在某些测试中甚至可能无需向磁盘写入任何数据，其性能仅受制于内核进行 memcpy() 的速度。这种模型与 FFS 严格的同步写入形成鲜明对比。ext2 所做的权衡十分明确：在 Linux 系统中，重启事件很少，保证系统在其余 99.99% 的时间里高速运行，比因同步写入而降低性能更为划算。

当然，这种一致性模型也并非没有缺陷，对某些应用可能完全不合适。由于 ext2 不保证操作的执行顺序和刷新时机，存在（虽不大）“后续修改已写入磁盘，而早先操作尚未写入”的可能。虽然文件系统一致性检查可以确保文件系统的整体一致性，但操作顺序的随意性可能导致应用行为异常，甚至因文件系统修改顺序不一致而崩溃。

尽管上述风险听起来严重，但在实际使用中此类情况极为罕见。通常情况下，ext2 的速度比传统基于 FFS 的文件系统快一个数量级。
