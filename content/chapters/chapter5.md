---
typora-root-url: ./..\..\public
---

# 属性、索引和查询

本章讨论三个密切相关的主题：属性、索引和查询。这三项功能为文件系统增添了强大的能力，并赋予文件系统许多通常只有数据库才具备的特性。本章旨在说明为什么属性、索引和查询是现代文件系统的重要功能。我们将既讨论这些机制的高层次问题，也深入讲解 BFS（Be File System）的具体实现细节。

## 5.1 属性

什么是属性？一般来说，属性是一个名称（通常是一个简短的描述性字符串）和一个值，例如数字、字符串，甚至原始二进制数据。例如，一个属性可以有一个名为“年龄”的名称和一个值为 27 的值，或者一个名为“关键字”的名称和一个值为“计算机 文件系统 日志”的值。属性是关于实体的信息。在文件系统的上下文中，属性是关于文件的附加信息，这些信息没有存储在文件本身中。能够将关于文件的信息与文件一起存储但不在文件内部存储是非常重要的，因为通常修改文件的内容来存储这些信息是不可行的——甚至是不可能的。

程序可以在属性中存储许多类型的数据，例如：

- 窗口系统的图标位置和信息
- 已下载 Web 文档的源 URL
- 文件的类型
- 文件的上次备份日期
- 电子邮件的“收件人”、“发件人”和“主题”行
- 文档中的关键字
- 安全系统的访问控制列表
- 富文本编辑器的样式信息（字体、大小等）
- 图像的伽马校正、颜色深度和尺寸
- 关于文件的评论
- 联系人数据库信息（地址、电话/传真号码、电子邮件地址、URL）

这些是关于对象的信息示例，但它们不一定是我们会——甚至能够——存储在对象本身中的信息。这些示例仅仅开始触及我们可能存储在属性中的信息种类。将任意名称/值对附加到文件的能力开启了许多有趣的可能性。

### 属性的使用示例

考虑管理人员信息的需要。电子邮件程序需要一个人的电子邮件地址，联系人管理器需要一个电话号码，传真程序需要一个传真号码，而文字处理器的邮件合并功能需要一个实际地址。这些程序中的每一个都有特定的需求，通常每个程序都会拥有其所需的关于人的信息的私有副本，尽管许多信息最终会在每个应用程序中重复。如果关于某个人的某条信息应该更改，则需要更新几个不同的程序——这不是理想的情况。

相反，使用属性，文件系统可以将人表示为一个文件。文件的名称将是人的姓名，或者可能是更唯一的标识符。这个“人文件”的属性可以维护关于人的信息：电子邮件地址、电话号码、传真号码、URL 等等。然后，上面提到的每个程序都简单地访问它需要的属性。所有程序都从同一个地方获取信息。此外，需要存储不同信息的程序可以添加和修改其他属性，而不会干扰现有程序。

在这个例子中，属性的强大之处在于许多程序可以轻松地共享信息。因为对属性的访问是统一的，所以应用程序只需要就属性的名称达成一致。这有助于程序协同工作，消除了浪费的数据重复，并使程序不必都实现自己的小型数据库。另一个好处是，需要先前未知属性的新应用程序可以添加新属性，而不会中断使用旧属性的其他程序。在这个例子中，将信息存储为属性也带来了其他好处。从用户的角度来看，存在一个关于人员信息的单一界面。他们可以期望，如果在电子邮件程序中选择一个人，电子邮件程序将使用该人的电子邮件属性并允许用户向他们发送电子邮件。同样，如果用户将“人文件”的图标拖放到传真程序上，很自然地会期望传真程序知道您想向该人发送传真。在这个例子中，属性提供了一种简单的方法来集中存储关于人员的信息，并以一种有助于应用程序之间共享的方式进行存储。

其他不太复杂的例子比比皆是。Web 浏览器可以存储已下载文件的源 URL，以便用户稍后可以询问“返回到此文件来自的站点”。图像扫描程序可以将关于扫描的颜色校正信息作为文件的属性存储。使用字体和样式的文本编辑器可以将关于文本的样式信息作为属性存储，而将原始文本保留为纯 ASCII（这将允许使用多种字体、样式、颜色等编辑源代码）。文本编辑器可以合成文档中包含的主要关键字，并将这些关键字存储为文档的属性，以便以后可以搜索包含某种类型内容的文件。

这些例子都说明了如何使用属性。属性为程序提供了一种存储关于文件的数据的机制，这种方式使得以后很容易检索信息并与其他应用程序共享信息。

### 属性 API

可以对属性执行许多操作，但 BeOS 中的文件系统接口保持列表简短。程序可以对文件属性执行以下操作：

- 写入属性
- 读取属性
- 打开属性目录
- 读取属性目录
- 重置属性目录
- 关闭属性目录
- 获取属性状态
- 删除属性
- 重命名属性

毫不奇怪，这些操作与文件的相应操作非常相似，并且它们的行为几乎相同。要访问文件的属性，程序必须首先打开该文件，并使用该文件描述符作为访问属性的句柄。文件的属性没有单独的文件描述符。文件的属性目录类似于常规目录。程序可以打开它并遍历它以枚举文件的所有属性。

值得注意的是，列表中缺少像我们对常规文件那样打开和关闭属性的操作。因为属性不使用单独的文件描述符进行访问，所以打开和关闭操作是多余的。用户级 API 调用以从属性读取和写入数据具有以下原型：

```c
ssize_t fs_read_attr(int fd, const char *attribute, uint32 type, off_t pos, void *buf, size_t count);
ssize_t fs_write_attr(int fd, const char *attribute, uint32 type, off_t pos, const void *buf, size_t count);
```

每个调用都封装了执行 I/O 所需的所有状态。文件描述符指示要操作哪个文件，属性名称指示要对哪个属性执行 I/O，类型指示正在写入的数据类型，而位置指定在属性中的偏移量以执行 I/O。属性读/写操作的语义与文件读/写操作的语义相同。写操作还有一个额外的语义：如果属性名称不存在，它将隐式创建它。写入现有属性将覆盖该属性（除非位置非零，在这种情况下，如果该属性已经存在，它将扩展该属性）。

列出文件属性的函数与列出目录内容的标准 POSIX 函数非常相似。打开属性目录操作启动对属于文件的属性列表的访问。打开属性目录操作返回一个文件描述符，因为与读取目录相关的状态无法在用户空间中维护。读取属性目录操作返回下一个连续条目，直到没有更多条目为止。重置操作将目录流中的位置重置到目录的开头。当然，关闭操作只是关闭文件描述符并释放相关的状态。

其余的操作（stat、remove 和 rename）是典型的内务管理操作，没有细微之处。stat 操作给定一个文件描述符和属性名称，返回关于属性大小和类型的信息。remove 操作从与文件关联的属性列表中删除指定的属性。rename 操作目前在 BFS 中尚未实现。

### 属性细节

如前所述，属性是一个字符串名称和一些任意的数据块。在 BeOS 中，属性还声明了与名称一起存储的数据类型。数据类型可以是整数类型（字符串、整数或浮点数），也可以是任意大小的原始数据。类型字段仅在严格意义上是支持索引所必需的。

在决定使用什么数据结构来存储属性时，我们的第一个想法可能是定义一个新的数据结构。但是，如果我们抵制住这种诱惑，并仔细查看属性必须存储的内容，我们会发现其描述与文件的描述惊人地相似。在最基本的层面上，属性是一个命名的实体，它必须存储任意数量的数据。虽然大多数属性很可能都很小，但在属性中存储大量数据非常有用并且需要完全支持。考虑到这一点，重用文件底层的数据结构（即 i 节点）是很有意义的。i 节点表示磁盘上的数据流，因此可以存储任意数量的信息。通过将属性的内容存储在 i 节点的数据流中，文件系统不必管理一组专门用于属性的单独数据结构。

与文件关联的属性列表也需要一个数据结构和存储位置。借鉴我们观察到的属性与文件的相似性，很自然地将属性列表存储为目录。目录正是完成此任务所需的属性：它将名称映射到 i 节点。将所有结构绑定在一起所需的最后一部分是文件 i 节点到属性目录 i 节点的引用。图 5-1 图示了这些结构之间的关系。然后可以从文件 i 节点遍历到列出所有属性的目录。从目录条目中可以找到每个属性的 i 节点，并且访问属性 i 节点使我们能够访问属性的内容。

![figure5-1](/images/chapter5/figure5-1.png)

这种实现是最容易理解和实现的。这种方法的唯一缺点是，虽然理论上很优雅，但实际上其性能将非常糟糕。性能会受到影响，因为每个属性都需要多次磁盘操作才能找到和加载。BFS 的初始设计使用了这种方法。当它第一次呈现给其他工程师时，由于访问属性所需的间接级别，它很快就被否决了（并且这样做是正确的）。

这种性能瓶颈是一个问题，因为在 BeOS 中，窗口系统将文件的图标位置存储为文件的属性。因此，使用这种设计，当显示目录中的所有文件时，每个文件至少需要一次磁盘访问来获取文件 i 节点，一次访问来加载属性目录 i 节点，另一次目录访问来查找属性名称，另一次访问来加载属性 i 节点，最后还需要一次磁盘访问来加载属性的数据。鉴于当前的磁盘驱动器的访问时间约为毫秒级（有时是数十毫秒），而 CPU 速度达到亚 5 纳秒级，很明显，强迫 CPU 等待五次磁盘访问来显示单个文件将严重影响性能。

我们知道文件的许多属性都很小，并且提供对它们的快速访问将使许多程序受益。本质上，问题在于文件的至少一些属性需要更有效的访问。解决方案与大约在同一时间出现的另一个设计问题结合在一起。BFS 需要能够在卷上存储任意数量的文件，并且预先在卷上为 i 节点保留空间被认为不可接受。在文件系统初始化时保留 i 节点的空间是管理 i 节点的传统方法，但这会导致在文件很少的大型驱动器上浪费大量空间，并且总是会成为文件很多但 i 节点不足的文件系统的限制。BFS 只需要消耗磁盘上存储的文件所需的空间——不多也不少。这意味着 i 节点很可能存储为单独的磁盘块。最初看来，将每个 i 节点存储在其自己的磁盘块中会浪费太多空间，因为 i 节点结构的大小只有 232 字节。然而，当这种存储 i 节点的方法与需要存储几个小属性以进行快速访问的需求相结合时，解决方案就很清楚了。i 节点块的剩余空间适合存储文件的小属性。BFS 将 i 节点块末尾的这个空间称为小数据区。从概念上讲，BFS i 节点如图 5-2 所示。

![figure5-2](/images/chapter5/figure5-2.png)

因为并非所有属性都能放入 i 节点的小数据区，所以 BFS 继续使用属性目录和 i 节点来存储额外的属性。访问非常驻属性的成本确实高于小数据区中的属性，但这种权衡是值得的。最常见的情况非常高效，因为一次磁盘读取将检索 i 节点和许多通常最需要的小属性。

小数据区纯粹是 BFS 的实现细节，对程序员完全透明。事实上，不可能请求将属性放入小数据区。暴露这种性能优化的细节会破坏原本清晰的属性 API。

好的，以下是原文的中文翻译：

#### 小数据区域详情

BFS 用于管理小数据区域空间的结构体定义为：

```c
typedef struct small_data {
    uint32 type;
    uint16 name_size;
    uint16 data_size;
    char name[1];
} small_data;
```

这个数据结构经过优化，以使其尽可能小，从而可以在 i-node 中封装尽可能多的实例。name_size 和 data_size 这两个大小字段被限制为 16 位整数，因为我们知道 i-node 的大小永远不会超过 8K。type 字段也应该是 16 位，但我们必须保留从更高层软件传递进来的确切类型。

name 字段的内容大小可变，并开始于 small_data 结构体的最后一个字段（结构体中的成员 name 仅仅是一个便于引用构成名称的字节起始位置的方式，而不是一个只有单字符的固定大小名称）。属性的数据部分存储在 name 后面的字节中，没有填充。一个产生指向 small_data 结构体数据部分的指针的 C 宏定义如下：

```c
#define SD_DATA(sd) \
    (void *)((char *)sd + sizeof(*sd) + (sd->name_size-sizeof(sd->name)))
```

以典型的令人费解的 C 编程风格，这个宏使用了指针算术来生成一个指向可变大小 name 字段后面字节的指针。

图 5-3 展示了小数据区域的使用方式。

![figure5-3](/images/chapter5/figure5-3.png)

所有操作 small_data 结构体的例程都期望一个指向 i-node 的指针，在 BFS 中，这个指针不仅仅是指 i-node 结构体本身，而是 i-node 所在的整个磁盘块。存在以下例程来操作 i-node 的小数据区域：

- 查找具有给定名称的 small_data 结构体
- 创建具有名称、类型和数据的新 small_data 结构体
- 更新现有的 small_data 结构体
- 获取 small_data 结构体的数据部分
- 删除 small_data 结构体

从 i-node 地址开始，第一个 small_data 结构体的地址可以通过将 i-node 结构体的大小添加到其地址轻松计算出来。得到的指针是小数据区域的基址。有了第一个 small_data 结构体的地址，操作小数据区域的例程都期望并维护一个紧密 packed 的 small_data 结构体数组。空闲空间始终是数组中的最后一个项，并被管理为一个 type 为零、名称长度为零、数据大小等于剩余空闲空间大小（不包括结构体本身的大小）的 small_data 项。

由于 BFS 尽可能紧密地 packed small_data 结构体，任何给定的 small_data 结构体实例都不太可能在“好”的内存边界上对齐（即，“好”边界是四或八的倍数的地址）。这可能在某些 RISC 处理器上导致对齐异常。如果将 BeOS 移植到像 MIPS 这样的架构上，BFS 必须先将 small_data 结构体复制到 Properly aligned 的临时变量中，然后从那里进行解引用，这将使代码变得复杂得多。由于 BeOS 当前运行的 CPU（PowerPC 和 Intel x86）没有这个限制，当前的 BFS 代码忽略了这个问题，尽管它是非可移植的。

i-node 的小数据区域非常适合存储一系列紧密 packed 的属性。然而，实现并不完美，BFS 还可以使用其他技术进一步减小小数据结构体的大小。例如，可以使用 C 的 union 类型来消除固定大小属性（如整数或浮点数）的大小字段。或者属性名称可以存储为哈希值，而不是显式字符串，然后在哈希表中查找字符串。尽管这些技术可以节省一些空间，但它们会使代码更加复杂，并且更难以调试。尽管看起来很简单，但 small_data 属性的处理经过了多次迭代才最终正确。

### 大局：小数据属性及更多

前面的描述详细介绍了使用 small_data 结构体的机制，但没有提供太多关于它如何与 BFS 的通用属性机制联系起来的见解。正如我们之前讨论的，一个文件可以有任意数量的属性，每个属性都是任意大小的名称/值对。文件系统内部必须管理 reside 在小数据区域以及位于属性目录中的属性。

概念上管理这两组属性是直观的。每次程序请求属性操作时，文件系统会检查属性是否在小数据区域中。如果不在，它 then 会在属性目录中查找该属性。然而，在实践中，这增加了代码的复杂性。例如，写属性操作使用了列表 5-1 中所示的算法。

```c
if length of data being written is small
 find the attribute name in the small_data area 
    if found
  delete it from small_data and from any indices
 else
  create the attribute name
 write new data
 if it fits in the small_data area
  delete it from the attribute directory if present
 else
  create the attribute in the attribute directory 
        write the data to the attribute i-node 
        delete name from the small_data area if it exists
else
 create the attribute in the attribute directory 
    write the data to the attribute i-node 
    delete name from the small_data area if it exists

```

诸如在将属性添加到小数据区域后将其从属性目录中删除之类的微妙之处，在重写现有属性导致属性位置发生变化的情况下是必需的。

操作 reside 在文件属性目录中的属性变得更容易，因为许多操作可以重用适用于文件的现有操作。在属性目录中创建属性使用与在目录中创建文件相同的底层函数。同样，读、写和删除属性的操作使用与文件相同的例程。这些操作所需的 glue code 具有类似于对小数据区域操作的微妙之处（如果在将属性写入属性目录时存在于小数据区域中，则需要从 small_data 区域中删除属性，等等）。

文件系统可重入性是另一个增加复杂性的问题。由于文件系统使用相同的操作访问属性目录和属性，我们必须小心，确保相同的资源永远不会被第二次锁定（这将导致死锁）。幸运的是，像这样的死锁问题如果遇到会非常 catastrophic，从而易于检测（文件系统会锁定）并纠正（很容易检查有问题代码的状态，并从那里回溯到解决方案）。

### 属性总结

属性的基本概念是一个名称以及与该名称关联的一些数据块。属性可以是简单的事情：

```c
Keywords = bass, guitar, drums
```

或者它可以是更复杂的关联数据。与属性关联的数据是自由形式的，可以存储任何内容。在文件系统中，属性通常附加到文件上，并存储关于文件内容的信息。

实现属性并不困难，尽管直接的实现将在性能方面受到影响。为了加速属性访问，BFS 直接在文件的 i-node 中支持一个快速属性区域。快速属性区域显著降低了访问属性的成本。
