# 日志

Journaling（日志记录），也称为logging，是一种确保磁盘上数据结构正确性的机制。本章的目标是解释什么是journaling，文件系统如何实现它，以及提高journaling性能的技术。

为了理解journaling，我们首先需要理解它试图解决的问题。如果系统在更新磁盘上的数据结构时崩溃，该数据结构可能会损坏。如果在多次更新之间发生崩溃，需要更新多个磁盘块的操作就会面临风险。在对数据结构进行两次修改之间发生的崩溃将导致操作只完成一部分。部分更新的数据结构本质上是一个损坏的结构，因此文件系统必须特别小心以避免这种情况。

磁盘只能保证对单个磁盘块的写入能够成功。也就是说，对单个磁盘块的更新要么成功，要么失败。对磁盘上单个块的写入是一个不可分割（即原子性）的事件；不可能只部分写入一个磁盘块。如果文件系统的任何操作都不需要更新超过一个磁盘块，那么崩溃造成的损害是有限的：要么磁盘块被写入了，要么没有。不幸的是，磁盘上的数据结构通常需要修改几个不同的磁盘块，所有这些块都必须正确写入才能认为更新完成。如果数据结构的部分块被修改，可能会导致操纵该数据结构的软件损坏用户数据或崩溃。

如果在修改数据结构时发生灾难性情况，系统下次访问数据结构时，必须仔细验证数据结构。这包括遍历整个数据结构以修复之前系统停止造成的任何损坏——这是一个乏味且耗时的过程。

Journaling是数据库领域发明的一种技术，它通过确保对结构的每次更新要么完全发生，要么完全不发生，即使更新跨越多个磁盘块，从而保证了磁盘上数据结构的正确性。如果文件系统使用journaling，它可以假定，除非有bug或磁盘故障，其磁盘上的数据结构将保持一致，无论发生崩溃、断电或其他灾难性情况。此外，journaled文件系统的恢复与其大小无关。journaled卷的崩溃恢复大约只需几秒钟，而不是像大型非journaled文件系统那样需要数十分钟。保证一致性和快速恢复是journaling提供的两个主要特性。

在不了解细节的情况下，journaling可能看起来像魔术。正如我们将看到的，事实并非如此。此外，journaling并不能防止所有类型的故障。例如，如果一个磁盘块变坏且无法再从中读取或写入，journaling不会（也无法）提供任何保证或保护。更高级别的软件必须始终准备好处理物理磁盘故障。Journaling在它提供的保护方面有几个实际限制。

## 7.1 基础知识

在日志文件系统中，一个事务是在一次操作期间对文件系统磁盘上结构所做的完整修改集合。例如，创建一个文件是一个单一的事务，它包括在文件创建期间修改的所有磁盘块。一个事务对于故障而言被认为是原子性的。一个事务要么完全发生（例如，文件被创建），要么根本不发生。当最后一次修改完成时，一个事务就结束了。即使事务结束了，在所有修改过的磁盘块都在磁盘上更新之前，它仍然没有完成。这种事务结束和事务完成之间的区别很重要，稍后会讨论。事务是journaling最基本的单位。

思考事务内容的另一种方式是从高层次来看待它们。在高层次上，我们可以将一个事务视为一个单一的操作，例如“创建文件X”或“删除文件Y”。这是一种比将事务视为一系列修改过的块更紧凑的表示方式。低层次视图不重视块的内容；它只是记录了哪些块被修改了。更紧凑、更高层次的视图需要对底层数据结构有深入的了解才能解释日志的内容，这使得journaling的实现更加复杂。事务的低层次视图实现起来要简单得多，并且具有独立于文件系统数据结构的优点。

当一个事务的最后一次修改完成时（即它结束了），事务的内容被写入日志。日志是磁盘上一个固定大小的连续区域，journaling代码将其用作一个循环缓冲区。用来指代日志的另一个术语是journal。journaling系统将所有事务记录在日志区域中。出于性能原因，可以将日志放在与文件系统其余部分不同的设备上。日志只在正常操作期间写入，并且当旧事务完成时，它们在日志中的空间会被回收。日志是journaling操作的核心。

当一个事务被写入日志后，有时也被称为一个日志条目（journal entry）。一个日志条目包含修改过的磁盘块的地址以及属于每个块的数据。日志条目通常存储为一个单独的内存块，并写入卷的日志区域。当一个journaled系统重新启动时，如果存在任何未标记为完成的日志条目，系统必须重放这些条目以使系统保持最新状态。重放日志可以防止部分更新，因为每个日志条目都是一个完整、自包含的事务。

Write-ahead logging（预写式日志）是指journaling系统在修改磁盘之前将更改写入日志。我们所知的所有journaling系统都使用write-ahead logging。我们假设journaling意味着write-ahead logging，并提及它只是为了完整性。

支持事务和日志的基本概念的是几个内存中的数据结构。这些结构在修改进行时将事务保存在内存中，并跟踪哪些事务已成功完成以及哪些事务正在 pending。这些结构当然会因不同的journaling实现而异。

## 7.2 Journaling 如何工作？

journaling 的基本前提是，一个事务中使用的所有修改过的块都锁定在内存中，直到事务完成。一旦事务完成，事务的内容就会写入日志，并且修改过的块被解锁。当所有缓存的块最终被刷新到磁盘上各自的位置时，该事务才被认为是完成的。在内存中缓冲事务并首先将数据写入日志可以防止部分更新的发生。

journaling 的关键在于它在允许将数据写入磁盘上的正常位置之前，先将事务的内容写入磁盘上的日志区域。也就是说，一旦一个事务成功写入日志，组成该事务的块就会从缓存中解锁。然后，缓存的块允许在未来的某个时间点（即缓存方便时将它们刷新到磁盘）写入其常规位置。当缓存将事务的最后一个块刷新到磁盘时，日志会被更新以反映该事务已完成。

journaling 背后的“魔法”在于，事务期间修改的磁盘块直到整个事务成功写入日志后才会被写入。通过在事务完成之前将其缓冲在内存中，journaling 避免了部分写入的事务。如果系统在成功写入日志条目之前崩溃，则该条目不被视为有效，并且该事务从未发生。如果系统在写入日志条目后崩溃，当它重新启动时，它会检查日志并重放未完成的事务。这种重放事务的概念是 journaling 一致性保证的关键。

当一个 journaling 系统重放一个事务时，它会有效地重新执行该事务。如果日志存储了构成事务一部分的修改过的磁盘块，那么重放一个事务就仅仅是将其这些磁盘块写入磁盘上正确的位置。如果日志存储了事务的高层表示，那么重放日志涉及重新执行这些操作（例如，创建文件）。当系统完成重放日志后，journaling 系统会更新日志，以便将其标记为干净。如果在重放日志期间系统崩溃，也不会造成损害，系统下次启动时日志将再次被重放。重放事务使系统恢复到已知的一致状态，并且必须在执行对文件系统的任何其他访问之前完成。

如果我们按照创建文件所涉及事件的时间线（如图 7-1 所示），我们可以看到 journaling 如何保证一致性。对于这个例子，我们将假设创建文件只需要修改两个块：一个用于分配 i-node，一个用于将新文件名添加到目录中。

如果系统在时间 A 崩溃，系统仍然是一致的，因为文件系统尚未被修改（日志中没有任何内容写入，也没有块被修改）。如果在时间 C 之前的任何时候系统崩溃，事务都没有完成，因此日志认为该事务没有发生。尽管在时间 C 之前的任何时候发生崩溃，文件系统仍然一致，因为原始块没有被修改。如果系统在时间 C 和 D 之间崩溃（在写入日志条目时），日志条目只完成了一部分。这不影响系统的一致性，因为日志在检查日志时总是忽略部分完成的事务。此外，没有其他块被修改，所以就像事务从未发生过一样。

如果系统在时间 D 崩溃，日志条目是完整的。在时间 D 或之后崩溃的情况下，当系统重新启动时，它将重放日志，更新磁盘上相应的块，并且文件将被成功创建。在时间 E 或 F 崩溃与在时间 D 崩溃类似。就像之前一样，文件系统将重放日志并将日志中的块写入磁盘上正确的位置。即使在时间 D 和 E 之间可能已经更新了一些实际的磁盘块，也不会造成损害，因为日志包含的值与这些块相同。

在时间 F 之后崩溃与我们的事务无关，因为所有磁盘块都已更新，并且日志条目标记为完成。在时间 F 之后崩溃甚至不会知道文件被创建了，因为日志已经被更新以反映事务已完成。
