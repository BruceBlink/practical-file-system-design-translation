---
typora-root-url: ./..\..\public\
---

# 日志

Journaling（日志记录），也称为logging，是一种确保磁盘上数据结构正确性的机制。本章的目标是解释什么是journaling，文件系统如何实现它，以及提高journaling性能的技术。

为了理解journaling，我们首先需要理解它试图解决的问题。如果系统在更新磁盘上的数据结构时崩溃，该数据结构可能会损坏。如果在多次更新之间发生崩溃，需要更新多个磁盘块的操作就会面临风险。在对数据结构进行两次修改之间发生的崩溃将导致操作只完成一部分。部分更新的数据结构本质上是一个损坏的结构，因此文件系统必须特别小心以避免这种情况。

磁盘只能保证对单个磁盘块的写入能够成功。也就是说，对单个磁盘块的更新要么成功，要么失败。对磁盘上单个块的写入是一个不可分割（即原子性）的事件；不可能只部分写入一个磁盘块。如果文件系统的任何操作都不需要更新超过一个磁盘块，那么崩溃造成的损害是有限的：要么磁盘块被写入了，要么没有。不幸的是，磁盘上的数据结构通常需要修改几个不同的磁盘块，所有这些块都必须正确写入才能认为更新完成。如果数据结构的部分块被修改，可能会导致操纵该数据结构的软件损坏用户数据或崩溃。

如果在修改数据结构时发生灾难性情况，系统下次访问数据结构时，必须仔细验证数据结构。这包括遍历整个数据结构以修复之前系统停止造成的任何损坏——这是一个乏味且耗时的过程。

Journaling是数据库领域发明的一种技术，它通过确保对结构的每次更新要么完全发生，要么完全不发生，即使更新跨越多个磁盘块，从而保证了磁盘上数据结构的正确性。如果文件系统使用journaling，它可以假定，除非有bug或磁盘故障，其磁盘上的数据结构将保持一致，无论发生崩溃、断电或其他灾难性情况。此外，journaled文件系统的恢复与其大小无关。journaled卷的崩溃恢复大约只需几秒钟，而不是像大型非journaled文件系统那样需要数十分钟。保证一致性和快速恢复是journaling提供的两个主要特性。

在不了解细节的情况下，journaling可能看起来像魔术。正如我们将看到的，事实并非如此。此外，journaling并不能防止所有类型的故障。例如，如果一个磁盘块变坏且无法再从中读取或写入，journaling不会（也无法）提供任何保证或保护。更高级别的软件必须始终准备好处理物理磁盘故障。Journaling在它提供的保护方面有几个实际限制。

## 7.1 基础知识

在日志文件系统中，一个事务是在一次操作期间对文件系统磁盘上结构所做的完整修改集合。例如，创建一个文件是一个单一的事务，它包括在文件创建期间修改的所有磁盘块。一个事务对于故障而言被认为是原子性的。一个事务要么完全发生（例如，文件被创建），要么根本不发生。当最后一次修改完成时，一个事务就结束了。即使事务结束了，在所有修改过的磁盘块都在磁盘上更新之前，它仍然没有完成。这种事务结束和事务完成之间的区别很重要，稍后会讨论。事务是journaling最基本的单位。

思考事务内容的另一种方式是从高层次来看待它们。在高层次上，我们可以将一个事务视为一个单一的操作，例如“创建文件X”或“删除文件Y”。这是一种比将事务视为一系列修改过的块更紧凑的表示方式。低层次视图不重视块的内容；它只是记录了哪些块被修改了。更紧凑、更高层次的视图需要对底层数据结构有深入的了解才能解释日志的内容，这使得journaling的实现更加复杂。事务的低层次视图实现起来要简单得多，并且具有独立于文件系统数据结构的优点。

当一个事务的最后一次修改完成时（即它结束了），事务的内容被写入日志。日志是磁盘上一个固定大小的连续区域，journaling代码将其用作一个循环缓冲区。用来指代日志的另一个术语是journal。journaling系统将所有事务记录在日志区域中。出于性能原因，可以将日志放在与文件系统其余部分不同的设备上。日志只在正常操作期间写入，并且当旧事务完成时，它们在日志中的空间会被回收。日志是journaling操作的核心。

当一个事务被写入日志后，有时也被称为一个日志条目（journal entry）。一个日志条目包含修改过的磁盘块的地址以及属于每个块的数据。日志条目通常存储为一个单独的内存块，并写入卷的日志区域。当一个journaled系统重新启动时，如果存在任何未标记为完成的日志条目，系统必须重放这些条目以使系统保持最新状态。重放日志可以防止部分更新，因为每个日志条目都是一个完整、自包含的事务。

Write-ahead logging（预写式日志）是指journaling系统在修改磁盘之前将更改写入日志。我们所知的所有journaling系统都使用write-ahead logging。我们假设journaling意味着write-ahead logging，并提及它只是为了完整性。

支持事务和日志的基本概念的是几个内存中的数据结构。这些结构在修改进行时将事务保存在内存中，并跟踪哪些事务已成功完成以及哪些事务正在 pending。这些结构当然会因不同的journaling实现而异。

## 7.2 Journaling 如何工作？

journaling 的基本前提是，一个事务中使用的所有修改过的块都锁定在内存中，直到事务完成。一旦事务完成，事务的内容就会写入日志，并且修改过的块被解锁。当所有缓存的块最终被刷新到磁盘上各自的位置时，该事务才被认为是完成的。在内存中缓冲事务并首先将数据写入日志可以防止部分更新的发生。

journaling 的关键在于它在允许将数据写入磁盘上的正常位置之前，先将事务的内容写入磁盘上的日志区域。也就是说，一旦一个事务成功写入日志，组成该事务的块就会从缓存中解锁。然后，缓存的块允许在未来的某个时间点（即缓存方便时将它们刷新到磁盘）写入其常规位置。当缓存将事务的最后一个块刷新到磁盘时，日志会被更新以反映该事务已完成。

journaling 背后的“魔法”在于，事务期间修改的磁盘块直到整个事务成功写入日志后才会被写入。通过在事务完成之前将其缓冲在内存中，journaling 避免了部分写入的事务。如果系统在成功写入日志条目之前崩溃，则该条目不被视为有效，并且该事务从未发生。如果系统在写入日志条目后崩溃，当它重新启动时，它会检查日志并重放未完成的事务。这种重放事务的概念是 journaling 一致性保证的关键。

当一个 journaling 系统重放一个事务时，它会有效地重新执行该事务。如果日志存储了构成事务一部分的修改过的磁盘块，那么重放一个事务就仅仅是将其这些磁盘块写入磁盘上正确的位置。如果日志存储了事务的高层表示，那么重放日志涉及重新执行这些操作（例如，创建文件）。当系统完成重放日志后，journaling 系统会更新日志，以便将其标记为干净。如果在重放日志期间系统崩溃，也不会造成损害，系统下次启动时日志将再次被重放。重放事务使系统恢复到已知的一致状态，并且必须在执行对文件系统的任何其他访问之前完成。

如果我们按照创建文件所涉及事件的时间线（如图 7-1 所示），我们可以看到 journaling 如何保证一致性。对于这个例子，我们将假设创建文件只需要修改两个块：一个用于分配 i-node，一个用于将新文件名添加到目录中。

![figure7-1](images/chapter7/figure7-1.png)

如果系统在时间 A 崩溃，系统仍然是一致的，因为文件系统尚未被修改（日志中没有任何内容写入，也没有块被修改）。如果在时间 C 之前的任何时候系统崩溃，事务都没有完成，因此日志认为该事务没有发生。尽管在时间 C 之前的任何时候发生崩溃，文件系统仍然一致，因为原始块没有被修改。如果系统在时间 C 和 D 之间崩溃（在写入日志条目时），日志条目只完成了一部分。这不影响系统的一致性，因为日志在检查日志时总是忽略部分完成的事务。此外，没有其他块被修改，所以就像事务从未发生过一样。

如果系统在时间 D 崩溃，日志条目是完整的。在时间 D 或之后崩溃的情况下，当系统重新启动时，它将重放日志，更新磁盘上相应的块，并且文件将被成功创建。在时间 E 或 F 崩溃与在时间 D 崩溃类似。就像之前一样，文件系统将重放日志并将日志中的块写入磁盘上正确的位置。即使在时间 D 和 E 之间可能已经更新了一些实际的磁盘块，也不会造成损害，因为日志包含的值与这些块相同。

在时间 F 之后崩溃与我们的事务无关，因为所有磁盘块都已更新，并且日志条目标记为完成。在时间 F 之后崩溃甚至不会知道文件被创建了，因为日志已经被更新以反映事务已完成。

好的，这是对您提供的英文文本中 7.3 节和 7.4 节的中文翻译：

## 7.3 Journaling 的类型

在文件系统中，主要有两种形式的 journaling。第一种风格称为旧值/新值日志记录（old-value/new-value logging），它记录事务一部分的旧值和新值。例如，如果一个文件被重命名，旧名称和新名称都会被记录到日志中。记录这两个值使得文件系统能够中止一个更改并恢复数据结构的旧状态。旧值/新值日志记录的缺点是必须写入日志的数据量增加了一倍。能够回滚一个事务非常有用，但旧值/新值日志记录的实现要困难得多，而且由于写入日志的数据更多而速度较慢。

为了实现旧值/新值日志记录，文件系统必须在修改磁盘块之前记录任何磁盘块的状态。这可能会使 B+tree 等算法复杂化，因为它们在修改其中一个节点之前可能需要检查许多节点。旧值/新值日志记录要求对代码的最低层进行修改，以确保它们正确地存储它们修改的任何块的未修改状态。

仅新值日志记录（new-value-only logging）是另一种 journaling 风格。仅新值日志记录只记录对磁盘块所做的修改，而不记录原始值。在文件系统中支持仅新值日志记录相对简单，因为代码执行正常块写入的任何地方都简单地变成了对日志的写入。仅新值日志记录的一个缺点是它不允许中止事务。无法中止事务使得错误恢复变得复杂，但这种权衡是值得的。仅新值日志记录写入的数据量是旧值/新值日志记录的一半，因此速度更快，并且需要更少的内存来缓冲更改。

## 7.4 什么会被日志记录？

关于 journaling 的主要困惑之一是日志中到底包含什么。日志只包含对文件系统元数据（metadata）的修改。也就是说，日志包含对目录、位图（bitmap）、i-node 的更改，以及在 BFS 中，包含对索引的更改。日志不包含对存储在文件（或 BFS 中的属性）中的用户数据的修改。这意味着，如果文本编辑器保存一个新文件，新文件的内容不会在日志中，但新的目录条目、i-node 和修改过的位图块会存储在日志条目中。这是关于 journaling 的一个重要点。journaling 不仅不在日志中存储用户数据，而且也不能这样做。如果日志也要记录用户数据，可以写入日志的数据量将是无界的。由于日志是固定大小的，事务永远不能大于日志的大小。如果用户写入的数据量大于日志的大小，文件系统就会卡住，并且没有地方存放所有的用户数据。用户程序可以写入比固定大小日志所能存储的数据量更多的数据，因此用户数据不会写入日志。

Journaling 只保证文件系统数据结构的完整性。Journaling 不保证用户数据始终完全是最新的，也不保证文件系统数据结构相对于崩溃时的时间点是最新的。如果一个日志文件系统在向一个新文件写入数据时崩溃，当系统重新启动时，文件数据可能不正确，而且文件甚至可能不存在。文件系统有多新取决于文件系统和日志缓冲区的数据量。

journaling 的一个重要方面是，虽然文件系统可能是一致的，但系统不必也是最新的。在日志系统中，一个事务要么完全发生，要么完全不发生。这可能意味着即使在崩溃前（从程序的角度来看）成功创建的文件，在重新启动后也可能不存在。

很自然会问，为什么 journaling 不能同时保证文件系统是最新的？如果 journaling 最多只缓冲一个事务，它可以提供这个保证。通过一次只缓冲一个事务，如果发生崩溃，只有崩溃时正在进行的最后一个事务会被撤销。但只缓冲一个事务会增加写入日志的磁盘次数，这会显著降低文件系统的速度。只缓冲一个事务引入的速度下降是如此显著，以至于大多数文件系统宁愿提供更高的吞吐量，而不是更好的时间点一致性保证。文件系统所属的其余系统的对一致性的需求决定了 journaling 代码应该进行多少缓冲或进行多少缓冲。

## 7.5 超越 Journaling

Berkeley 日志结构文件系统（Log Structured File System, LFS）通过将整个磁盘视为日志区域并将所有内容（包括用户数据）写入日志来扩展 journaling 的概念。在 LFS 中，文件从未被删除，它们只是被重写。LFS 通过查找已被后续事务取代的事务来回收日志空间。

LFS 将其日志事务以大的连续块写入，这是写入磁盘最快的方式。不幸的是，当磁盘几乎满时（磁盘的稳定状态），LFS 可能不得不搜索大量的日志条目才能找到一个空闲区域。这种搜索的开销可能会抵消大块写入带来的好处。回收日志空间的任务可能非常耗时，并且需要锁定文件系统。LFS 假设回收日志空间是那种可以在深夜运行的任务。这个假设对于持续运行的 Unix 式系统来说很好，但对于桌面环境来说效果不佳，因为桌面环境可能不总是运行。

有趣的是，由于 LFS 从不覆盖文件，它有潜力隐含地对所有文件进行版本控制。由于 LFS 不会就地重写文件，因此可以提供钩子来定位文件的先前版本并检索它。这种功能也适用于恢复已删除的文件甚至撤销文件保存。然而，当前版本的 LFS 尚未实现此功能。日志结构文件系统仍然是一个研究领域。尽管 LFS 随 BSD 4.4 发布，但由于磁盘满时回收空间相关的缺点，它通常不用于商业系统。LFS 的详细信息超出了本书的范围（有关日志结构文件系统的更多信息，请参阅 Mendel Rosenblum 撰写的论文）。

## 7.6 代价是什么？

Journaling 为文件系统提供了两个显著的优点：保证元数据的一致性（除非发生硬件故障）以及在发生故障时的快速恢复。journaling 最明显的代价是元数据必须写入两次（一次到日志，一次到其常规位置）。令人惊讶的是，写入两次数据并不会影响性能——在某些情况下甚至可以提高性能！

写入两倍的文件系统元数据怎么可能提高性能呢？答案很简单：数据的第一次写入是到日志区域，并且与其他元数据一起进行批量处理，形成一次大的连续写入（即速度很快）。当数据随后从缓存刷新时，缓存管理器可以按磁盘地址对块列表进行排序，这最大限度地减少了写入块时的寻道时间。对块进行排序带来的差异是显著的。最终的证明体现在性能数据上。对于各种文件系统元数据密集型基准测试（例如，创建和删除文件），日志文件系统可能比传统的同步写入文件系统（例如 Solaris 中使用的 Berkeley Fast File System）快几倍。我们将在第 9 章中介绍更多关于性能的细节。

日志文件系统面临的最大瓶颈是所有事务都写入一个单一的日志。使用单一日志，所有事务在进行修改之前都必须锁定对日志的访问。单一日志有效地将文件系统 Updates 强制进入单线程模型。如果需要支持大量的并发文件系统修改，这是一个严重的缺点。

解决这个问题的显而易见的方案是支持多个日志文件。具有多个日志文件的系统将允许独立写入每个日志，从而允许事务并行发生。多个日志需要对事务进行时间戳标记，以便日志回放可以正确地按顺序处理不同日志中的事务。多个日志还需要重新审视文件系统中使用的锁定方案。

允许更多并发访问日志的另一种技术是让每个事务预留固定数量的块，然后独立于其他事务管理该空间。这也带来了许多锁定和排序问题。例如，后一个事务可能比前一个事务花费更少的时间完成，因此刷新该事务可能需要等待前一个事务完成。SGI 的 XFS 使用了这种技术的一种变体，尽管他们在论文中没有详细描述。

当前版本的 BFS 没有实现这两种提高日志并发访问的技术。BFS 的主要用途可能不是在面向事务的环境中，而且到目前为止，现有的性能已被证明是足够的。
