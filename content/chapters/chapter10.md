---
typora-root-url: ./..\..\public\
---



# Vnode 层 (The Vnode Layer)

一个操作系统几乎总是有其自身的本地文件系统格式，但仍然经常需要访问其他类型的文件系统。例如，CD-ROM 介质经常使用 ISO-9660 文件系统来存储数据，并且能够访问这些信息是可取的。此外，还有许多其他原因使得访问不同的文件系统成为必需：数据传输、互操作性和简单的便利性。所有这些原因对于 BeOS 尤其如此，因为它必须与许多其他操作系统共存。

BeOS（以及大多数 Unix 版本）为方便访问不同文件系统所采用的方法是设置一个文件系统独立层，该层协调对不同文件系统的访问。该层通常被称为虚拟文件系统层或 vnode（虚拟节点）层。“vnode 层”这一术语起源于 Unix。vnode 是文件或目录的通用表示，对应于真实文件系统中的 i-node。vnode 层为内核的其余部分提供了访问文件和目录的统一接口，而无论底层文件系统是什么。

vnode 层通过定义一组由每个文件系统实现的函数，将特定文件系统的实现与系统的其余部分分离开来。vnode 层定义的这组函数抽象了文件和目录的通用概念。每个文件系统都实现这些函数，并将每个通用操作映射到在特定文件系统格式中执行该操作的细节。

本章描述 BeOS vnode 层、它支持的操作、期望文件系统遵循的协议，以及有关文件描述符实现及其如何映射到 vnode 的一些细节。

## 10.1 背景 (Background)

要理解 BeOS vnode 层，首先描述 BeOS vnode 层运行的框架会很有帮助。BeOS 内核管理线程 (threads) 和团队 (teams)（Unix 术语中的“进程”），但文件描述符和所有 I/O 都完全属于 vnode 层的 purview。图 10-1 说明了 vnode 层如何与内核的其余部分以及几个文件系统相结合。vnode 层通过文件描述符与用户程序交互，并通过 vnode 操作与不同的文件系统通信。在图 10-1 中，有三个文件系统（BFS、Macintosh HFS 和 NFS）。

![figure10-1](/images/chapter10/figure10-1.png)

BeOS 中的 vnode 层完全隐藏了管理文件描述符的细节，内核的其余部分对此毫不知情。文件描述符是按线程管理的。BeOS 线程结构为每个线程维护一个指向 I/O 上下文 (I/O context) 的指针 `ioctx`。`ioctx` 结构对于内核的其余部分是不透明的；只有 vnode 层知道它。`ioctx` 结构中包含了 vnode 层所需的所有信息。

![figure10-2](/images/chapter10/figure10-2.png)

图 10-2 说明了协同工作以支持用户级别文件描述符概念的所有结构。虽然整体结构看起来复杂，但每个部分都非常简单。为了描述该结构，我们将从 `thread_rec` 结构开始，并贯穿整个图示，一直到由底层文件系统使用的结构。

每个线程都有其自己的 `ioctx` 结构。`ioctx` 包含一个指向每个线程当前工作目录 (cwd) 的指针、一个指向打开文件描述符数组 (`fdarray`) 的指针，以及一个受监控 vnode 列表 (`mon`；我们稍后将讨论这一点)。`fdarray` 维护有关文件描述符的状态，但主要成员是一个指针 `fds`，它指向一个 `ofile` 结构数组。`fdarray` 在同一团队中的所有线程之间共享。每个 `ofile` 维护有关文件打开方式（只读等）和文件中的位置的信息。然而，`ofile` 结构中最有趣的字段是 `vn` 指针。`vn` 字段指向一个 `vnode` 结构，这是 vnode 层的最低级别。

每个 `vnode` 结构是文件或目录的抽象表示。`vnode` 结构的 `data` 成员保存一个指针，该指针引用有关该 vnode 的文件系统特定信息。`data` 字段是文件或目录的抽象概念与特定文件系统上文件或目录的具体细节之间的连接。vnode 的 `ns` 字段指向一个名称空间 (name space) 结构，该结构保存有关此文件或目录所在文件系统的通用信息。名称空间结构还以类似于 vnode 的 `data` 字段的方式，保存一个指向每个文件系统特定结构的指针。

关于这个整体结构有几个关键点。一个团队中的每个线程都有一个指向同一个 `fdarray` 的指针，这意味着同一团队中的所有线程共享文件描述符。`fdarray` 中的每个条目都指向一个 `ofile` 结构，该结构又指向一个 `vnode`。`fdarray` 中的不同条目可以指向同一个 `ofile` 结构。POSIX 调用 `dup()` 依赖于此功能才能复制文件描述符。类似地，不同的 `ofile` 结构可以指向同一个 `vnode`，这对应于能够在同一程序或不同程序中多次打开文件的能力。在 `ofile` 结构中维护的信息与其引用的 `vnode` 之间的分离非常重要。

关于上图需要注意的另一件重要事情是，每个 `vnode` 结构都有一个 `vnode-id`。在 BeOS 中，每个 `vnode` 都有一个 `vnode-id`，它在单个文件系统上唯一地标识一个文件。为方便起见，我们将术语“vnode-id”缩写为“vnid”。给定一个 `vnid`，文件系统应该能够访问文件的 i-node。相反，给定目录中的一个名称，文件系统应该能够返回该文件的 `vnid`。

为了更好地理解如何使用此结构，让我们考虑一个在文件描述符上实际执行 write() 操作的具体示例。这一切都始于用户线程执行以下代码行：

```c
write(4, "hello world\n", 12);
```

在用户空间，函数 `write()` 是一个陷入内核的系统调用。一旦进入内核模式，内核系统调用处理程序将控制权传递给实现 `write()` 系统调用的内核例程。内核 `write()` 调用，即 `sys_write()`，是 vnode 层的一部分。从调用线程的 `ioctx` 结构开始，`sys_write()` 使用整数文件描述符（在本例中为值 4）来索引文件描述符数组 `fdarray`（由 `ioctx` 指向）。索引到 `fdarray` 会产生一个指向 `ofile` 结构的指针。`ofile` 结构包含状态信息（例如我们在文件中的当前位置）以及一个指向与此文件描述符关联的底层 `vnode` 的指针。`vnode` 结构引用特定的 `vnode`，并且还有一个指向包含有关此 `vnode` 所在文件系统信息的结构的指针。包含文件系统信息的结构有一个指向此文件系统支持的函数表的指针，以及一个由文件系统提供的文件系统状态结构。vnode 层使用函数指针表来调用文件系统的 `write()`，并使用适当的参数将数据写入与文件描述符关联的文件。

尽管这看起来像一条迂回且缓慢的路径，但这条从用户级别通过 vnode 层一直到特定文件系统的路径发生得非常频繁，并且必须相当高效。这个例子在许多方面都进行了简化（例如，我们根本没有讨论锁定），但它有助于演示从用户空间进入内核，然后通过特定文件系统的流程。

BeOS vnode 层还管理文件系统名称空间，并处理安装和卸载文件系统的所有方面。BeOS vnode 层维护已安装文件系统的列表以及它们在名称空间中的安装位置。此信息对于管理程序在层次结构中遍历时从一个文件系统透明地移动到另一个文件系统是必需的。

尽管 BeOS 的 vnode 层相当广泛，但它也与内核的其余部分高度封装。这种分离有助于在发生错误时隔离错误（vnode 层中的错误通常不会损坏线程其余部分的状态），并将 I/O 子系统中的更改与影响内核其余部分分离开来。这种 I/O 管理与系统其他方面（线程管理、VM 等）的清晰分离使用起来非常令人愉快。
