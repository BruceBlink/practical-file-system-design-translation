---
typora-root-url: ./..\..\public\
---



# Vnode 层 (The Vnode Layer)

一个操作系统几乎总是有其自身的本地文件系统格式，但仍然经常需要访问其他类型的文件系统。例如，CD-ROM 介质经常使用 ISO-9660 文件系统来存储数据，并且能够访问这些信息是可取的。此外，还有许多其他原因使得访问不同的文件系统成为必需：数据传输、互操作性和简单的便利性。所有这些原因对于 BeOS 尤其如此，因为它必须与许多其他操作系统共存。

BeOS（以及大多数 Unix 版本）为方便访问不同文件系统所采用的方法是设置一个文件系统独立层，该层协调对不同文件系统的访问。该层通常被称为虚拟文件系统层或 vnode（虚拟节点）层。“vnode 层”这一术语起源于 Unix。vnode 是文件或目录的通用表示，对应于真实文件系统中的 i-node。vnode 层为内核的其余部分提供了访问文件和目录的统一接口，而无论底层文件系统是什么。

vnode 层通过定义一组由每个文件系统实现的函数，将特定文件系统的实现与系统的其余部分分离开来。vnode 层定义的这组函数抽象了文件和目录的通用概念。每个文件系统都实现这些函数，并将每个通用操作映射到在特定文件系统格式中执行该操作的细节。

本章描述 BeOS vnode 层、它支持的操作、期望文件系统遵循的协议，以及有关文件描述符实现及其如何映射到 vnode 的一些细节。

## 10.1 背景 (Background)

要理解 BeOS vnode 层，首先描述 BeOS vnode 层运行的框架会很有帮助。BeOS 内核管理线程 (threads) 和团队 (teams)（Unix 术语中的“进程”），但文件描述符和所有 I/O 都完全属于 vnode 层的 purview。图 10-1 说明了 vnode 层如何与内核的其余部分以及几个文件系统相结合。vnode 层通过文件描述符与用户程序交互，并通过 vnode 操作与不同的文件系统通信。在图 10-1 中，有三个文件系统（BFS、Macintosh HFS 和 NFS）。

![figure10-1](/images/chapter10/figure10-1.png)

BeOS 中的 vnode 层完全隐藏了管理文件描述符的细节，内核的其余部分对此毫不知情。文件描述符是按线程管理的。BeOS 线程结构为每个线程维护一个指向 I/O 上下文 (I/O context) 的指针 `ioctx`。`ioctx` 结构对于内核的其余部分是不透明的；只有 vnode 层知道它。`ioctx` 结构中包含了 vnode 层所需的所有信息。

![figure10-2](/images/chapter10/figure10-2.png)

图 10-2 说明了协同工作以支持用户级别文件描述符概念的所有结构。虽然整体结构看起来复杂，但每个部分都非常简单。为了描述该结构，我们将从 `thread_rec` 结构开始，并贯穿整个图示，一直到由底层文件系统使用的结构。

每个线程都有其自己的 `ioctx` 结构。`ioctx` 包含一个指向每个线程当前工作目录 (cwd) 的指针、一个指向打开文件描述符数组 (`fdarray`) 的指针，以及一个受监控 vnode 列表 (`mon`；我们稍后将讨论这一点)。`fdarray` 维护有关文件描述符的状态，但主要成员是一个指针 `fds`，它指向一个 `ofile` 结构数组。`fdarray` 在同一团队中的所有线程之间共享。每个 `ofile` 维护有关文件打开方式（只读等）和文件中的位置的信息。然而，`ofile` 结构中最有趣的字段是 `vn` 指针。`vn` 字段指向一个 `vnode` 结构，这是 vnode 层的最低级别。

每个 `vnode` 结构是文件或目录的抽象表示。`vnode` 结构的 `data` 成员保存一个指针，该指针引用有关该 vnode 的文件系统特定信息。`data` 字段是文件或目录的抽象概念与特定文件系统上文件或目录的具体细节之间的连接。vnode 的 `ns` 字段指向一个名称空间 (name space) 结构，该结构保存有关此文件或目录所在文件系统的通用信息。名称空间结构还以类似于 vnode 的 `data` 字段的方式，保存一个指向每个文件系统特定结构的指针。

关于这个整体结构有几个关键点。一个团队中的每个线程都有一个指向同一个 `fdarray` 的指针，这意味着同一团队中的所有线程共享文件描述符。`fdarray` 中的每个条目都指向一个 `ofile` 结构，该结构又指向一个 `vnode`。`fdarray` 中的不同条目可以指向同一个 `ofile` 结构。POSIX 调用 `dup()` 依赖于此功能才能复制文件描述符。类似地，不同的 `ofile` 结构可以指向同一个 `vnode`，这对应于能够在同一程序或不同程序中多次打开文件的能力。在 `ofile` 结构中维护的信息与其引用的 `vnode` 之间的分离非常重要。

关于上图需要注意的另一件重要事情是，每个 `vnode` 结构都有一个 `vnode-id`。在 BeOS 中，每个 `vnode` 都有一个 `vnode-id`，它在单个文件系统上唯一地标识一个文件。为方便起见，我们将术语“vnode-id”缩写为“vnid”。给定一个 `vnid`，文件系统应该能够访问文件的 i-node。相反，给定目录中的一个名称，文件系统应该能够返回该文件的 `vnid`。

为了更好地理解如何使用此结构，让我们考虑一个在文件描述符上实际执行 write() 操作的具体示例。这一切都始于用户线程执行以下代码行：

```c
write(4, "hello world\n", 12);
```

在用户空间，函数 `write()` 是一个陷入内核的系统调用。一旦进入内核模式，内核系统调用处理程序将控制权传递给实现 `write()` 系统调用的内核例程。内核 `write()` 调用，即 `sys_write()`，是 vnode 层的一部分。从调用线程的 `ioctx` 结构开始，`sys_write()` 使用整数文件描述符（在本例中为值 4）来索引文件描述符数组 `fdarray`（由 `ioctx` 指向）。索引到 `fdarray` 会产生一个指向 `ofile` 结构的指针。`ofile` 结构包含状态信息（例如我们在文件中的当前位置）以及一个指向与此文件描述符关联的底层 `vnode` 的指针。`vnode` 结构引用特定的 `vnode`，并且还有一个指向包含有关此 `vnode` 所在文件系统信息的结构的指针。包含文件系统信息的结构有一个指向此文件系统支持的函数表的指针，以及一个由文件系统提供的文件系统状态结构。vnode 层使用函数指针表来调用文件系统的 `write()`，并使用适当的参数将数据写入与文件描述符关联的文件。

尽管这看起来像一条迂回且缓慢的路径，但这条从用户级别通过 vnode 层一直到特定文件系统的路径发生得非常频繁，并且必须相当高效。这个例子在许多方面都进行了简化（例如，我们根本没有讨论锁定），但它有助于演示从用户空间进入内核，然后通过特定文件系统的流程。

BeOS vnode 层还管理文件系统名称空间，并处理安装和卸载文件系统的所有方面。BeOS vnode 层维护已安装文件系统的列表以及它们在名称空间中的安装位置。此信息对于管理程序在层次结构中遍历时从一个文件系统透明地移动到另一个文件系统是必需的。

尽管 BeOS 的 vnode 层相当广泛，但它也与内核的其余部分高度封装。这种分离有助于在发生错误时隔离错误（vnode 层中的错误通常不会损坏线程其余部分的状态），并将 I/O 子系统中的更改与影响内核其余部分分离开来。这种 I/O 管理与系统其他方面（线程管理、VM 等）的清晰分离使用起来非常令人愉快。

## 10.2 Vnode 层概念 (Vnode Layer Concepts)

Vnode 层最重要的概念是 vnode。在 vnode 层本身内部，vnode 是一个抽象实体，由一个 64 位的 `vnid` 唯一标识。Vnode 层假设文件系统中的每个命名实体都有一个唯一的 `vnid`。给定一个 `vnid`，vnode 层可以请求文件系统加载相应的节点。

### 私有数据 (Private Data)

当 vnode 层请求文件系统加载特定的 `vnid` 时，它允许文件系统将一个指向私有数据的指针与该 `vnid` 相关联。文件系统在其 `read_vnode()` 例程中创建此私有数据结构。一旦 `vnid` 加载到内存中，vnode 层在调用文件系统以引用该节点时，总是传递文件系统的私有数据指针。每个 `vnode` 结构都有一个引用计数。当引用计数达到零时，vnode 层可以将该节点从内存中刷新，此时会调用文件系统以释放与私有数据相关的任何资源。

重要的是要注意，每个 vnode（以及关联的私有数据）在某种意义上是全局的，即许多操作同一文件的线程将使用相同的 `vnode` 结构。这就要求如果要修改该节点，则必须对其进行锁定，并且，该数据结构不适合存储特定于某个文件描述符的状态信息。

Vnode 层操作名称、`vnid` 和 vnode。当 vnode 层需要与文件系统通信时，它要么请求名称对应的 `vnid`，要么传递文件的 `vnid`，要么传递一个指向与某个 `vnid` 对应的 vnode 的文件系统私有数据的指针。文件系统从不直接看到 `vnode` 结构。相反，文件系统接收到的要么是一个 `vnid`，要么是当 vnode 层请求它加载 `vnid` 时它自己分配的每个节点的数据结构。Vnode 层和文件系统之间的接口仅将文件系统特定的信息传递给文件系统，而文件系统仅向 vnode 层发出涉及 `vnid` 的请求。

除了每个 vnode 保存的文件系统特定信息之外，vnode 层还允许文件系统提供一个对整个文件系统全局的结构。此结构包含有关文件系统特定实例的状态信息。Vnode 层总是将此结构传递给 vnode 层 API 定义的所有接口操作。因此，有了这个全局信息和每个 vnode 的信息，每个文件系统操作都只处理其自己的数据结构。同样，vnode 层也只处理其自己的结构，仅仅是调用文件系统特定层，并传递指向对 vnode 层不透明的文件系统特定信息的指针。

### Cookie (Cookies)

某些 vnode 层操作要求文件系统维护特定于单个文件描述符的状态信息。必须按文件描述符维护的状态不能保存在 vnode 的私有数据区域中，因为 `vnode` 结构是全局的。为了支持每个文件描述符的私有数据，vnode 层引入了“cookie”的概念。Cookie 是一个指向文件系统在连续调用其函数之间所需的私有状态信息的指针。Cookie 使得文件系统可以为每个文件描述符维护状态，尽管文件系统本身从不直接看到文件描述符。只有文件系统操作 cookie 的内容。Cookie 对 vnode 层是不透明的。Vnode 层仅跟踪 cookie，并在每个需要它的操作中将其传递给文件系统。

Vnode 层明确规定 cookie 的所有权由文件系统负责。文件系统分配一个 cookie 并填充其数据结构。Vnode 层跟踪指向该 cookie 的指针。Vnode 层确保文件系统在每个需要 cookie 的操作中都能接收到指向 cookie 的指针，但 vnode 层从不检查 cookie 的内容。当不再有对 cookie 的未完成引用时，vnode 层会请求文件系统释放与该 cookie 相关的资源。分配 cookie、管理其中的数据以及释放它的责任完全属于文件系统的范畴。

### Vnode 概念总结 (Vnode Concepts Summary)

每个 `vnid` 的数据结构、每个文件系统的状态结构以及 cookie 的概念有助于将 vnode 层与任何特定文件系统的具体细节隔离开来。这些结构中的每一个都存储与文件和文件系统相关的明确定义的信息片段。每个 `vnid` 的数据结构存储有关供所有人使用的文件的信息（例如文件大小）。每个文件系统的结构存储对整个文件系统全局的信息（例如卷上的块数）。Cookie 存储特定于某个文件描述符的私有信息（例如文件中的当前位置）。
