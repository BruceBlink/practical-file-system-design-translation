---
typora-root-url: ./..\..\public
---

# BFS的数据结构

## 4.1 什么是磁盘？

BFS（Be File System）将磁盘视为一个线性块数组，并在此基础抽象之上管理其所有数据结构。最底层，原始设备（如 SCSI 或 IDE 磁盘）都有一个设备块大小的概念，通常为 512 字节。BFS 中的“块”概念建立在原始设备块之上。文件系统块大小与原始设备块大小只有松散的耦合关系。对文件系统块大小的唯一限制是它必须是底层设备块大小的整数倍。也就是说，如果原始设备块大小是 512 字节，那么文件系统块大小可以是 512、1024 或 2048 字节。尽管也可以使用 1536 字节（3×512）这样的块大小，但由于它不是 2 的幂，这在性能上是非常糟糕的选择。虽然并非严格要求，但使用非 2 的幂块大小会对性能产生显著影响。

文件系统块大小还会影响虚拟内存系统（如果系统支持内存映射文件的话）。此外，如果希望将虚拟内存系统与缓冲缓存（buffer cache）统一起来，使文件系统块大小为 2 的幂是必需的（理想情况下，VM 页大小与文件系统块大小相等）。BFS 允许的块大小为 1024、2048、4096 或 8192 字节。我们不允许 512 字节块大小，是因为这样会导致某些关键的文件系统数据结构跨越多个块，给缓存管理和日志（journaling）带来复杂性，也会引起明显的性能下降。至于为什么最大块大小限定为 8192 字节，则需要先理解后面提到的其他结构，届时再作解释。

重要的是要认识到，文件系统块大小与磁盘容量无关（这点不同于 Macintosh HFS）。文件系统块大小的选择应根据磁盘上要存储的文件类型来决定：大量小文件在 8K 块下会造成大量空间浪费；而对于包含大文件的文件系统，则更适合使用更大的块，而非非常小的块。

## 4.2 如何管理磁盘块

管理磁盘空闲空间的方法有多种，最常见且最简单的是位图（bitmap）方案。其他方法有基于 extent 的和基于 B+ 树的（如 XFS）。BFS 出于简洁考虑，采用了位图方案。

位图方案将每个磁盘块表示为一个比特，文件系统将整个磁盘视为这些比特的数组。如果某个比特为 1，则对应磁盘块已被分配。计算位图所需空间（字节）的公式为：

```c
(disk size in bytes) / (filesystem block size × 8)
```

例如，对于一个 1 GB、块大小为 1 KB 的磁盘，其位图大小为 128 KB。

位图方案的主要缺点是，要寻找大块连续的空闲空间时，需要线性扫描整个位图。还有人认为，随着磁盘的逐渐填满，位图扫描的成本会增加；但实际上可以证明，查找位图中一个空闲比特的平均成本与位图的填充程度无关。正是因为这一点，加之实现简单，BFS 才使用了位图方案（尽管事后我也希望有时间去尝试其他分配方案）。

位图数据结构在磁盘上以一个连续的字节数组存储（向上取整至块大小的整数倍）。BFS 从块 1 开始存放位图（超级块 superblock 占据块 0）。在创建文件系统时，超级块和位图所占用的块会预先分配好。

## 4.3 分配组（Allocation Groups）

分配组是纯逻辑结构，没有对应的实际结构体。BFS 将构成文件系统的块数组划分为若干等大区块，称为“分配组”。分配组的概念用于将数据分散存放在磁盘上。

一个分配组就是磁盘上若干连续的块。分配组中块的数量与文件系统块大小及整个磁盘的位图大小密切相关。为了效率和方便，BFS 强制每个分配组的块数为一个位图块所映射块数的整数倍。以一个 1 GB、块大小为 1 KB 的磁盘为例，该磁盘的位图大小为 128 KB，因此占用 128 块。由于每个位图块为 1 KB，可映射 8192 块，故最小分配组大小为 8192 块。由于设计上的其它考量，最大分配组大小始终为 65 536 块。BFS 在选择分配组大小时，会在磁盘容量（对大分配组的需求）与分配组数量（不宜过多）之间进行平衡；实践中，通常用每 GB 空间约 8192 块作为分配组大小的经验值。

如前所述，BFS 使用分配组来分散数据存放。BFS 会尝试将文件的控制信息（i-node）放在与其父目录相同的分配组内；同时，BFS 会尝试将新创建的目录放在与包含它的目录不同的分配组中，文件数据也会放在与其控制信息不同的分配组。这样的布局策略倾向于将同一目录下的文件控制信息聚集在一个分配组，而将文件数据聚集在另一个分配组，从而使同一目录下的文件物理上靠得更近。需要注意的是，这只是一个建议策略；如果磁盘已接近满，唯一可用的空闲空间正好在同一分配组内，BFS 仍会进行分配。

为了提升分配块时的性能，BFS 在内存中维护了每个分配组在位图中的信息。每个分配组都记录了上次分配的空闲块索引，以便下次分配时无需从组开始处线性扫描；此外，还为每个分配组维护了“已满”标志，以便在分配组已无可用空间时，直接跳过对该组位图的扫描。

## 4.4 块运行（Block Runs）

块运行结构是 BFS 定位磁盘块的基本方式。其定义如下：

```c
typedef struct block_run {
    int32  allocation_group;
    uint16 start;
    uint16 len;
} block_run;
```

* `allocation_group` 字段指出所在的分配组；
* `start` 字段指出在该分配组内块运行的起始块号；
* `len` 字段指出该运行包含的块数。

该结构能表示的最大块号为 2^48（当块大小为 1 KB 时，对应最大磁盘容量约 2^58 字节）；尽管相比纯 64 位块号略显不足，但 2^58 字节的容量足以存储 217 年的 720×486 分辨率、4 字节/像素、30 帧/秒的未压缩视频，用量远超过可预见的需求。

`len` 字段为 16 位，最多可表示 65 536 块。对文件系统块大小较大时，单个 8 字节的块运行寻址最多可达数十 MB，已相当实用。但 `start` 字段也是 16 位无符号数，这意味着单个分配组最多 65 536 块，进而使得 8192 字节成为 BFS 文件系统块大小的上限：若允许更大块，位图每块映射更多块，分配组将超出 `start` 字段的可寻址范围，导致部分块无法分配。

BFS 将块运行结构用作 i-node 的寻址结构；在 i-node 寻址时，`len` 字段始终为 1。

## 4.5 超级块 (Superblock)

BFS 超级块包含许多字段，这些字段不仅描述了文件系统所在卷的物理大小，还包含有关日志区域和索引的附加信息。此外，BFS 存储了一些冗余信息，以便更好地对超级块、卷名和文件系统的字节顺序进行一致性检查。BFS 超级块数据结构如下：

```c
typedef struct disk_super_block {
    char name[B_OS_NAME_LENGTH]; // 卷名
    int32 magic1; // 魔数1
    int32 fs_byte_order; // 文件系统字节顺序
    uint32 block_size; // 块大小
    uint32 block_shift; // 块移位数
    off_t num_blocks; // 总块数
    off_t used_blocks; // 已用块数
    int32 inode_size; // i-node 大小
    int32 magic2; // 魔数2
    int32 blocks_per_ag; // 每个分配组的块数
    int32 ag_shift; // 分配组移位数
    int32 num_ags; // 分配组总数
    int32 flags; // 标志
    block_run log_blocks; // 日志块区域
    off_t log_start; // 日志起始位置
    off_t log_end; // 日志结束位置
    int32 magic3; // 魔数3
    inode_addr root_dir; // 根目录 i-node 地址
    inode_addr indices; // 索引 i-node 地址
    int32 pad[8]; // 填充字节
} disk_super_block;
```

你会注意到超级块中存储了三个魔数。挂载文件系统时，这些魔数是确保正确性的第一轮健全性检查。请注意，这些魔数分布在整个数据结构中，这样如果数据结构的任何部分损坏，比仅在结构开头设置一两个魔数更容易检测到损坏。

魔数的值是完全任意的，但被选择为较大且具有一定趣味性的 32 位值：

```c
#define SUPER_BLOCK_MAGIC1 0x42465331 /* BFS1 */
#define SUPER_BLOCK_MAGIC2 0xdd121031
#define SUPER_BLOCK_MAGIC3 0x15b6830e
```

超级块中的第一个实际信息是文件系统的块大小。BFS 以两种方式存储块大小。第一种是 `block_size` 字段，它是一个明确的字节数。因为 BFS 要求块大小是 2 的幂，所以存储将块号转换为字节地址所需的移位位数也很方便。我们为此使用 `block_shift` 字段。存储两种形式的块大小可以在挂载文件系统时提供额外的检查级别：在有效的文件系统中，`block_size` 和 `block_shift` 字段必须一致。

接下来的两个字段，`num_blocks` 和 `used_blocks`，记录了此卷上可用的块数以及当前正在使用的块数。这些值的类型是 `off_t`，在 BeOS 上是 64 位整数。`off_t` 并非必须是 64 位，实际上 BFS 的早期开发版本仅为 32 位，因为当时编译器不支持 64 位数据类型。`num_blocks` 和 `block_size` 字段准确地告诉您磁盘有多大。将它们相乘的结果是文件系统可用的确切字节数。`used_blocks` 字段记录文件系统当前正在使用的块数。此信息并非绝对必要，但维护起来比每次想知道磁盘有多满时都去计算位图中所有置位（为 1 的位）的总和要方便得多。

下一个字段 `inode_size` 告诉我们每个 i-node（即文件控制块）的大小。与大多数 Unix 文件系统不同，BFS 不使用预分配的 i-node 表。相反，BFS 按需分配 i-node，并且每个 i-node 至少占用一个磁盘块。这看起来可能过多，但正如我们稍后将描述的那样，事实证明它并没有像你最初想象的那样浪费那么多空间。BFS 主要在为空闲节点分配空间时使用 `inode_size` 字段，但它也在其他一些情况下用作一致性检查（i-node 大小必须是文件系统块大小的倍数，并且 i-node 本身会存储其大小，以便可以与超级块中的 `inode_size` 字段进行验证）。

除了超级块中记录的这些信息外，分配组没有与之关联的实际数据结构。超级块的 `blocks_per_ag` 字段指的是每个分配组中的位图块数。由于上述原因，每个分配组的位图块数映射的块数不得超过 65,536 个。与 `block_shift` 字段类似，`ag_shift` 字段记录了在将块运行地址转换为字节偏移量（反之亦然）时对分配组号进行移位的位数。`num_ags` 字段是此文件系统中的分配组数，用于控制和检查块运行结构的分配组字段。

`flags` 字段记录超级块的状态：是干净 (clean) 还是脏 (dirty)？

因为 BFS 是日志文件系统，所以它总是以 `BFS_CLEAN` (0x434c454e) 的值写入超级块。在内存中，在修改磁盘的事务期间，该字段设置为 `BFS_DIRTY` (0x44495254)。挂载时会检查 `flags` 字段以验证文件系统是否干净。

关于日志的信息是我们在超级块中找到的下一块信息。日志（在第 7 章中深入描述）是记录对文件系统即将进行的更改的区域。就超级块而言，日志只是一个连续的磁盘块数组。因此，超级块主要需要记录一个块运行数据结构，该结构描述构成日志的磁盘区域。为了维护日志的状态以及我们在其中的位置（因为日志是一个循环缓冲区），我们还在变量 `log_start` 和 `log_end` 中维护指向日志开始和结束的指针。

超级块结构的最后两个成员，`root_dir` 和 `indices`，将超级块与卷上存储的所有数据连接起来。根目录 i-node 的地址是将超级块连接到卷上所有文件和目录层次结构根的连接点。索引目录 i-node 的地址将超级块与卷上存储的索引连接起来。

没有这两条信息，BFS 将无法找到磁盘上的任何文件。正如我们稍后将看到的，拥有磁盘上 i-node 的地址使我们能够获取该 i-node 的内容（无论它是目录还是文件）。i-node 地址只是一个 `len` 字段为 1 的块运行结构。

当文件系统处于活动使用状态时，超级块会加载到内存中。内存中有一个 `bfs_info` 结构，它包含超级块的副本、用于访问底层设备的文件描述符、信号量以及有关文件系统的其他状态信息。`bfs_info` 结构存储访问卷上所有其他内容所需的数据。

## 4.6 I-Node 结构 (The I-Node Structure)

当用户打开一个文件时，他们使用人类可读的名称打开它。该名称是一个字符串，易于人们处理。与该名称关联的是一个 i-node 号，这便于文件系统处理。在 BFS 中，文件的 i-node 号是 i-node 数据结构在磁盘上存储位置的地址。文件的 i-node 对于访问该文件的内容（即读取或写入文件等）至关重要。

i-node 数据结构维护有关存在于文件系统中的实体的元信息。i-node 必须记录诸如文件大小、所有者、创建时间、最后修改时间以及有关文件的各种其他信息。i-node 中最重要的信息是关于属于此 i-node 的数据在磁盘上存在位置的信息。也就是说，i-node 是将您连接到文件中数据的连接点。这种基本结构是在文件系统中如何在文件中存储数据的基础构建块。BFS i-node 结构如下：

```c
typedef struct bfs_inode {
    int32 magic1; // 魔数1
    inode_addr inode_num; // i-node 号（即其在磁盘上的地址）
    int32 uid; // 用户ID
    int32 gid; // 组ID
    int32 mode; // 文件模式（权限和类型）
    int32 flags; // 标志
    bigtime_t create_time; // 创建时间
    bigtime_t last_modified_time; // 最后修改时间
    inode_addr parent; // 父目录 i-node 地址
    inode_addr attributes; // 属性目录 i-node 地址
    uint32 type; // 类型（用于属性）
    int32 inode_size; // i-node 大小
    binode_etc *etc; // 指向内存中额外信息的指针（磁盘上为NULL）
    data_stream data; // 数据流
    int32 pad[4]; // 填充字节
    int32 small_data[1]; // 小数据区（用于非常小的文件或符号链接）
} bfs_inode;
```

我们再次看到使用魔数进行一致性检查。i-node 的魔数是 `0x3bbe0ad9`。如果需要，魔数也可以用于识别不同版本的 i-node。例如，如果将来有必要添加或更改 i-node，新格式的 i-node 可以使用不同的魔数来标识自己。

我们还将此 i-node 的 i-node 号存储在其自身内部，这样就可以很容易地简单地维护一个指向内存中磁盘块的指针，并且仍然记住它在磁盘上的来源。此外，`inode_num` 字段提供了另一个一致性检查点。

`uid/gid` 字段是维护文件所有权信息的简单方法。这些字段与 POSIX 风格的 `uid/gid` 字段非常相似（只是它们是 32 位大小）。

`mode` 字段存储文件访问权限信息以及有关文件是常规文件还是目录的信息。BFS 中的文件权限模型非常严格地遵循 POSIX 1003.1 规范。也就是说，存在用户、组和“其他”对文件系统实体的访问概念。三种权限类型是读取、写入和执行。这是一种非常简单的权限检查模型（并且它具有相应简单的实现）。

管理所有权信息的另一种方法是通过访问控制列表 (ACL)。ACL 具有许多优点，但在完成 BFS 的可用时间内实现 ACL 被认为是不合理的。ACL 存储有关哪些用户可以访问文件系统项目的显式信息。这比标准的 POSIX 权限模型精细得多；事实上，它们是获得某些形式的美国政府安全认证（例如，C2 级安全）所必需的。也许可以使用文件属性（稍后讨论）来实现 ACL，但该途径尚未被探索。

与往常一样，`flags` 字段对于记录 i-node 的各种状态信息非常有用。BFS 需要了解有关 i-node 的几件事，其中一些是永久记录的，另一些仅在内存中使用时才使用。BFS 当前理解的标志是：

```c
#define INODE_IN_USE 0x00000001 // I-node 正在使用
#define ATTR_INODE 0x00000004 // 这是一个属性 i-node
#define INODE_LOGGED 0x00000008 // I-node 的数据流被记录日志
#define INODE_DELETED 0x00000010 // I-node 已被删除
#define PERMANENT_FLAGS 0x0000ffff // 永久标志掩码
#define INODE_NO_CACHE 0x00010000 // 不缓存此 i-node (仅内存)
#define INODE_WAS_WRITTEN 0x00020000 // I-node 已被写入 (仅内存)
#define NO_TRANSACTION 0x00040000 // 不为此 i-node 启动事务 (仅内存)
```

所有活动的 i-node 始终设置 `INODE_IN_USE` 标志。如果 i-node 引用属性，则设置 `ATTR_INODE` 标志。`ATTR_INODE` 标志会影响 BFS 的其他部分如何处理该 i-node。

`INODE_LOGGED` 标志对 BFS 如何处理 i-node 有很大影响。设置此标志后，写入此 i-node 引用的数据流的所有数据都将被记录日志。也就是说，当此 i-node 的数据流发生修改时，更改将像任何其他日志事务一样被记录日志（有关更多详细信息，请参见第 7 章）。

到目前为止，`INODE_LOGGED` 标志的唯一用途是用于目录。目录的内容构成文件系统元数据信息——系统正确运行所必需的信息。因为损坏的目录将是灾难性的故障，所以对目录内容的任何更改都必须记录在日志中以防止损坏。

`INODE_LOGGED` 标志具有潜在的严重影响。记录写入文件的所有数据可能会溢出日志（同样，有关更完整的描述，请参见第 7 章）。因此，唯一设置此标志的 i-node 是目录，其中对数据段执行的 I/O 量可以合理地限制并且受到非常严格的控制。

当用户删除文件时，文件系统会为与该文件对应的 i-node 设置 `INODE_DELETED` 标志。`INODE_DELETED` 标志表示不再允许访问该文件。虽然此标志在内存中设置，但 BFS 不会费心将 i-node 写回磁盘，从而在文件删除期间节省了一次额外的磁盘写入。

其余标志仅影响 i-node 加载到内存中时的处理方式。关于 BFS 如何使用这些其他标志的讨论留给它们相关的章节。

回到 i-node 的其余字段，我们找到了 `create_time` 和 `last_modified_time` 字段。与 Unix 文件系统不同，BFS 维护文件的创建时间，并且不维护最后访问时间（通常称为 atime）。维护最后访问时间的成本很高，而且通常最后修改时间就足够了。维护最后访问时间的性能成本（即每次接触文件时都进行一次磁盘写入）对于它获得的少量用途来说实在太高了。

为了提高时间字段索引的效率，BFS 将它们存储为 `bigtime_t`，这是一个 64 位整数。存储的值是一个普通的 POSIX `time_t` 值左移 16 位，并与一个小计数器进行逻辑或运算。这种操作的目的是帮助创建唯一的时间值，以避免时间索引中不必要的重复（有关更多详细信息，请参见第 5 章）。

下一个字段 `parent` 是指回包含此文件的目录的引用。该字段的存在与 Unix 风格的文件系统不同。BFS 需要 `parent` 字段来支持从 i-node 重建完整路径名。在处理查询（在第 5 章中描述）时，需要从 i-node 重建完整路径名。

下一个字段 `attributes` 可能是 BFS 中 i-node 最不传统的部分。字段 `attributes` 是一个 i-node 地址。它指向的 i-node 是一个包含有关此文件属性的目录。属性目录中的条目是与文件的属性（名称/值对）对应的名称。我们稍后将讨论属性以及此字段的必要性，因为它们需要冗长的解释。

`type` 字段仅适用于存储属性的 i-node。属性索引要求它们具有类型（整数、字符串、浮点数等），此字段维护该信息。为此字段选择名称 `type` 可能比它应有的语义包袱更重一些：它绝不是用来存储诸如 Macintosh HFS 的类型和创建者字段之类的信息。BeOS 将有关文件的真实类型信息存储为名为 `BEOS:TYPE` 的属性中的 MIME 字符串。

`inode_size` 字段主要是一个健全性检查字段。BFS 的早期开发版本以更有意义的方式使用该字段，但现在它只是在从磁盘加载 i-node 时执行的另一个检查。

`etc` 字段只是一个指向有关 i-node 的内存信息的指针。它是存储在磁盘上的 i-node 结构的一部分，这样，当我们将文件系统的一个块加载到内存中时，就可以就地使用它，而无需在使用之前调整磁盘上的表示。
