---
typora-root-url: ./..\..\public\
---

# 磁盘块缓存 (The Disk Block Cache)

当系统中两个设备在访问较慢设备的频率上存在显著不匹配时，系统的整体吞吐量实际上可能会降低到较慢设备的水平。为了缓解这种情况，系统设计者通常会在设计中加入缓存，以降低访问慢速设备的成本。

缓存通过提供对驻留在慢速设备上的数据的更快访问来降低访问设备的成本。为此，缓存会将慢速设备上存在的数据副本保存在一个检索速度更快的区域。缓存之所以有效，是因为它提供数据的速度远快于从其在慢速设备上的实际位置检索相同数据的速度。换句话说，缓存将自身置于快速设备和慢速设备之间，并透明地为快速设备提供一种错觉，即较慢的设备比实际速度更快。

本章讨论与设计磁盘缓存相关的问题，如何决定在缓存中保留什么内容，如何决定何时从缓存中删除某些内容，以及所涉及的数据结构。

## 8.1 背景 (Background)

缓存使用一定数量的缓冲空间来保存常用数据的副本。访问缓冲空间的速度比访问底层的慢速设备要快。缓存使用的缓冲空间永远无法容纳底层设备的所有数据。如果缓存可以容纳慢速设备的所有数据，那么缓存将简单地取代慢速设备。当然，缓冲空间越大，缓存的效果就越好。缓存系统的主要任务是管理缓冲区中的数据块。

磁盘缓存使用系统内存来保存驻留在磁盘上的数据副本。要使用缓存，程序请求一个磁盘块，如果缓存中已经有该块，则直接从缓存中读取或写入该块，而无需访问磁盘。在读取操作中，如果请求的块不在缓存中，缓存会从磁盘读取该块，并在缓存中保留一份数据副本，同时满足请求。在向不在缓存中的块写入数据时，缓存会为新数据腾出空间，将其标记为“脏” (dirty)，然后返回。脏数据会在稍后更方便的时候刷新到磁盘（可能会将多次写入操作合并为一次写入）。

管理缓存主要在于决定在缓存已满时保留哪些内容以及剔除哪些内容。这种管理对缓存的性能至关重要。如果有用的数据过早地从缓存中被丢弃，缓存的性能将不如预期。如果缓存没有在适当的时候从缓存中丢弃旧数据，缓存的有效大小和效率将大大降低。

磁盘缓存的有效性是衡量请求的数据在缓存中被找到的频率。如果一个磁盘缓存可以容纳 1024 个不同的磁盘块，而一个程序请求的数据块从未超过 1024 个，那么缓存的有效性将是 100%，因为一旦缓存读入了所有块，就不再访问磁盘。在另一个极端情况下，如果一个程序随机请求数万个不同的磁盘块，那么缓存的有效性可能会接近于零，每个请求都必须访问磁盘。幸运的是，访问模式往往更具规律性，磁盘缓存的有效性也更高。

除了程序可能请求的块数之外，这些引用的局部性 (locality of those references) 也在缓存的有效性中起着作用。一个程序请求的块数可能多于缓存中的块数，但如果磁盘块的地址是顺序的，那么缓存仍然可能有用。在其他情况下，访问的磁盘块数可能多于缓存的大小，但其中一些磁盘块的访问次数可能远多于其他块，因此缓存将保留重要的块，从而降低访问它们的成本。大多数程序都具有高度的引用局部性，这有助于提高磁盘缓存的有效性。

## 8.2 缓冲缓存的组织 (Organization of a Buffer Cache)

磁盘缓存有两个主要需求。首先，给定一个磁盘块号，缓存应该能够快速返回与该磁盘块关联的数据。其次，当缓存已满并请求新数据时，缓存必须决定从缓存中丢弃哪些块。这两个需求需要两种不同的方法来访问底层数据。第一个任务，即在给定磁盘块地址的情况下有效查找数据块，使用了显而易见的哈希表解决方案。第二种访问方法需要一种能够快速决定从缓存中刷新哪些块的组织方式。有几种可能的实现来解决这个问题，但最常见的是一个从最近使用过 (MRU) 的块到最少使用过 (LRU) 的块排序的双向链表。以这种方式排序的双向链表通常被称为 LRU 列表（其头部是 MRU 端，尾部是 LRU 端）。哈希表和 LRU 列表紧密地交织在一起，对它们的访问需要仔细协调。

我们讨论的缓存管理侧重于哈希表和 LRU 列表的这种双重结构。除了使用 LRU 列表来决定从缓存中丢弃哪个块之外，我们本可以使用其他算法，例如随机替换、工作集模型、基于时钟的算法或 LRU 列表的变体（例如最不常使用）。在设计 BFS 时，如果能对这些其他算法进行实验以确定哪种算法在典型工作负载下表现最佳，那将是很好的。不幸的是，时间限制要求缓存得到实现，而不是进行实验，因此对其他可能的算法的探索很少。

哈希表和 LRU 列表的基础是缓存管理的数据块。BeOS 设备缓存使用称为 `cache_ent` 的数据结构来管理数据块。`cache_ent` 结构维护一个指向数据块的指针、块号以及 LRU 列表的下一个/上一个链接。哈希表使用其自己的结构按块号进行索引，以检索指向关联 `cache_ent` 结构的指针。

在图 8-1 中，我们说明了哈希表和双向链表的相互关系。为清晰起见，我们省略了从 `cache_ent` 结构到数据块的指针。

![figure8-1](/images/chapter8/figure8-1.png)

### 缓存读取 (Cache Reads)

首先，我们将考虑缓存为空且更高级别的代码从缓存请求一个块的情况。哈希表查找确定该块不存在。然后，缓存代码必须从磁盘读取该块并将其插入哈希表。将块插入哈希表后，缓存会将该块插入 LRU 列表的 MRU 端。随着从磁盘读取更多块，第一个被读取的块将随着其他块插入其前面而向列表的 LRU 端迁移。

如果我们最初的块再次被请求，哈希表的探测将会找到它，并且该块将被移动到 LRU 列表的 MRU 端，因为它现在是最近使用过的块（参见图 8-2）。这是缓存提供最大益处的地方：经常使用的数据将以哈希表查找和 `memcpy()` 的速度被找到和检索，而不是磁盘寻道和磁盘读取的成本，后者要慢几个数量级。

![figure8-2](/images/chapter8/figure8-2.png)

缓存不能无限增长，因此在某个时候，缓存管理的块数将达到最大值。当缓存已满并且请求不在缓存中的新块时，必须决定将哪个块踢出缓存。LRU 列表使这个决定变得容易。只需取出列表 LRU 端的块，我们就可以丢弃其内容并重用该块来读入新请求的块（参见图 8-3）。丢弃最近最少使用的块本质上是有道理的：如果该块很长时间没有被使用，那么它再次被需要的可能性就不大。删除 LRU 块不仅涉及将其从 LRU 列表中删除，还涉及从哈希表中删除该块号。回收 LRU 块后，新块被读入内存并放在 LRU 列表的 MRU 端。

![figure8-3](/images/chapter8/figure8-3.png)

### 缓存写入 (Cache Writes)

缓存写入有两种情况。第一种情况是正在写入的块已经在缓存中。在这种情况下，缓存可以将新写入的数据 `memcpy()` 覆盖它已经为特定磁盘块拥有的数据。缓存还必须将该块移动到 LRU 列表的 MRU 端（即，它成为最近使用过的数据块）。如果向一个磁盘块写入数据，并且该磁盘块不在缓存中，那么缓存必须为新的磁盘块腾出空间。为不在缓存中的新写入磁盘块在缓存中腾出空间与前面描述的缓存读取未命中时的情况相同。一旦有了新磁盘块的空间，数据就被复制到该块的缓存缓冲区中，并且 `cache_ent` 被添加到 LRU 列表的头部。如果出于数据完整性的原因，缓存必须执行写通 (write-through)，则缓存还必须将该块写入其对应的磁盘位置。

第二种也是更常见的情况是，该块仅被标记为脏 (dirty)，然后写入完成。稍后，当该块从缓存中刷新时，由于它已被标记为脏，它将被写入磁盘。如果系统在缓存中存在脏数据时崩溃或发生故障，磁盘上的数据将与内存中的数据不一致。

刷新缓存时，缓存中的脏块需要更多的工作。在前面描述的情况下，缓存中只有干净的块，刷新它们仅仅意味着重用它们的数据块来保存新数据。当存在脏块时，缓存必须首先将脏数据写入磁盘，然后才允许重用关联的数据块。正确处理脏块非常重要。如果由于任何原因，脏块在被丢弃之前没有刷新到磁盘，缓存将丢失对磁盘所做的更改，从而有效地损坏磁盘。
